#include <msp.h>
#include <string.h>
#include <stdio.h>
#include <driverlib.h>
#include "cmd_def.h"
#include "ble.h"

// switch between MASTER (OBC) and SLAVE (nOBC) modes
// slave device types are detected according to BLE MAC address
#define OBC

// from attributes.txt generated by bgbuild
#define xgatt_command 8
#define xgatt_data 11
#define xgatt_benchmark 14

#define MSP_LED1		GPIO_PORT_P1, GPIO_PIN0
#define MSP_LED2R		GPIO_PORT_P2, GPIO_PIN0
#define MSP_LED2G		GPIO_PORT_P2, GPIO_PIN1
#define MSP_LED2B		GPIO_PORT_P2, GPIO_PIN2
#define MSP_S1			GPIO_PORT_P1, GPIO_PIN1
#define MSP_S2			GPIO_PORT_P1, GPIO_PIN4

static volatile uint32_t tick_counter;
static volatile bool tick_second;


#ifdef OBC

// total number of connected slaves, number of large payload acceptors
#define NUM_CONN 8
#define NUM_LONG 2

// test mode
// 1 ... throughput benchmark with max possible payload
// 2 ... throughput benchmark with realistic scenario
// 3 ... realistic scenario once per second
#define TEST_MODE 3

// MAC addresses with byte-reversed order
const uint8_t conn_addr[][6] = {
	{ 0xCE, 0xB6, 0xE7, 0x80, 0x07, 0x00 }, // EPS
	{ 0xC5, 0xB6, 0xE7, 0x80, 0x07, 0x00 }, // ADCS
	{ 0xC6, 0xB6, 0xE7, 0x80, 0x07, 0x00 }, // GPS
	{ 0xC8, 0xB6, 0xE7, 0x80, 0x07, 0x00 }, // Propulsion
	{ 0xC9, 0xB6, 0xE7, 0x80, 0x07, 0x00 }, // TC Radio
	{ 0xCA, 0xB6, 0xE7, 0x80, 0x07, 0x00 }, // Payload
	{ 0xC7, 0xB6, 0xE7, 0x80, 0x07, 0x00 }, // Data Storage
	{ 0xCC, 0xB6, 0xE7, 0x80, 0x07, 0x00 }, // PL Radio
};

static bool connected[NUM_CONN];
static bool recv_attribute_value[NUM_CONN];
static bool recv_procedure_completed[NUM_CONN];

static uint32_t cnt_bytes, cnt_packets;
static uint32_t txok, txretry, rxok, rxfail;

#else

static uint8_t response_len;

#endif


/* UART Configuration Parameter. These are the configuration parameters to
 * make the eUSCI A UART module to operate with a 115200 baud rate. These
 * values were calculated using the online calculator that TI provides
 * at:
 * http://software-dl.ti.com/msp430/msp430_public_sw/mcu/msp430/MSP430BaudRateConverter/index.html
 */
const eUSCI_UART_Config uartConfig_PC =
{
	EUSCI_A_UART_CLOCKSOURCE_SMCLK,          // SMCLK Clock Source
	26,                                      // BRDIV
	0,                                       // UCxBRF
	111,                                     // UCxBRS
	EUSCI_A_UART_NO_PARITY,                  // No Parity
	EUSCI_A_UART_LSB_FIRST,                  // LSB First
	EUSCI_A_UART_ONE_STOP_BIT,               // One stop bit
	EUSCI_A_UART_MODE,                       // UART mode
	EUSCI_A_UART_OVERSAMPLING_BAUDRATE_GENERATION  // Oversampling
};


void SysTick_Handler(void)
{
    tick_counter++; // increment tick every 1ms
    if (tick_counter % 1000 == 0) tick_second = true;
}


#ifdef OBC

void ble_evt_connection_status(const struct ble_msg_connection_status_evt_t *msg)
{
	char s[64];

	if (msg->connection <= NUM_CONN) connected[msg->connection] = true;

    sprintf(s, "connected :%02x as %d, conn_interval %d, flags 0x%02x\n", msg->address.addr[0], msg->connection, msg->conn_interval, msg->flags);
    for (uint8_t i = 0; i < strlen(s); i++) MAP_UART_transmitData(EUSCI_A0_BASE, s[i]);
}


void ble_evt_connection_disconnected(const struct ble_msg_connection_disconnected_evt_t *msg)
{
	char s[64];

	if (msg->connection <= NUM_CONN) connected[msg->connection] = false;

    sprintf(s, "disconnected %d reason %04x\n", msg->connection, msg->reason);
    for (uint8_t i = 0; i < strlen(s); i++) MAP_UART_transmitData(EUSCI_A0_BASE, s[i]);
}


void ble_evt_attclient_procedure_completed(const struct ble_msg_attclient_procedure_completed_evt_t *msg)
{
	// ble_cmd_attclient_attribute_write() acknowledged
	// ble_cmd_attclient_read_by_handle() error
	// ble_cmd_attclient_read_long() done
	recv_procedure_completed[msg->connection] = true;
}

void ble_evt_attclient_attribute_value(const struct ble_msg_attclient_attribute_value_evt_t *msg)
{
	// ble_cmd_attclient_read_by_handle() value successfully received
	// ble_cmd_attclient_read_long() value successfully received
	recv_attribute_value[msg->connection] = true;
	cnt_bytes += msg->value.len;
	cnt_packets += 1;
}


void ble_rsp_system_get_counters(const struct ble_msg_system_get_counters_rsp_t *msg)
{
	txok += msg->txok;
	txretry += msg->txretry;
	rxok += msg->rxok;
	rxfail += msg->rxfail;
}


void main_benchmark_test(void)
{
	bool ok;
    const uint8_t data_packet[] = "123456789012345678901234567890";

    ble_sleep(false);
	for (uint8_t i = 0; i < NUM_CONN; i++) {
		recv_procedure_completed[i] = false;
		MAP_GPIO_setOutputHighOnPin(MSP_LED2R);
		ble_cmd_attclient_attribute_write(i, xgatt_benchmark, 20, data_packet);
		ble_rsp_wait();
		MAP_GPIO_setOutputLowOnPin(MSP_LED2R);
		cnt_bytes += 20;
		cnt_packets += 1;
	}
    ble_sleep(true);
	do {
		read_message();
		ok = true;
		for (uint8_t i = 0; i < NUM_CONN; i++) if (!recv_procedure_completed[i]) ok = false;
	} while (!ok); // wait for procedure completed
/*
    ble_sleep(false);
	for (uint8_t i = 0; i < NUM_CONN; i++) {
		recv_attribute_value[i] = false;
		MAP_GPIO_setOutputHighOnPin(MSP_LED2G);
		ble_cmd_attclient_read_by_handle(i, xgatt_benchmark);
		ble_rsp_wait();
		MAP_GPIO_setOutputLowOnPin(MSP_LED2G);
	}
    ble_sleep(true);
	do {
		read_message();
		ok = true;
		for (uint8_t i = 0; i < NUM_CONN; i++) if (!recv_attribute_value[i]) ok = false;
	} while (!ok); // wait for procedure completed
*/
}


void main_scenario_test(void)
{
    bool ok;
	const uint8_t cmd_packet[2] = {'a','b'};
    const uint8_t large_data_chunk[] = "12345678901234567890";

    ble_sleep(false);
	for (uint8_t i = 0; i < NUM_CONN; i++) {
		// send 2B command
		recv_procedure_completed[i] = false;
	    MAP_GPIO_setOutputHighOnPin(MSP_LED2R);
		ble_cmd_attclient_attribute_write(i, xgatt_command, 2, cmd_packet);
		ble_rsp_wait();
		MAP_GPIO_setOutputLowOnPin(MSP_LED2R);
		cnt_bytes += 2;
		cnt_packets += 1;
	}
    ble_sleep(true);
	do {
		read_message();
		ok = true;
		for (uint8_t i = 0; i < NUM_CONN; i++) if (!recv_procedure_completed[i]) ok = false;
	} while (!ok); // wait for procedure completed

    ble_sleep(false);
	for (uint8_t i = 0; i < NUM_CONN; i++) {
		// read arbitrary size response
		recv_procedure_completed[i] = false;
	    MAP_GPIO_setOutputHighOnPin(MSP_LED2G);
		ble_cmd_attclient_read_long(i, xgatt_data);
		ble_rsp_wait();
		MAP_GPIO_setOutputLowOnPin(MSP_LED2G);
	}
    ble_sleep(true);
	do {
		read_message();
		ok = true;
		for (uint8_t i = NUM_CONN-NUM_LONG; i < NUM_CONN; i++) if (!recv_procedure_completed[i]) ok = false;
	} while (!ok); // wait for procedure completed, just from long payload acceptors

	// send large 250B payload
	uint8_t offset = 0;
	while (offset < 250) {
		uint8_t len = 250-offset;
		if (len > 18) len = 18;

		MAP_GPIO_setOutputHighOnPin(MSP_LED2R);
		ble_sleep(false);
		for (uint8_t i = NUM_CONN-NUM_LONG; i < NUM_CONN; i++) {
			recv_procedure_completed[i] = false;
			ble_cmd_attclient_prepare_write(i, xgatt_data, offset, len, large_data_chunk);
			ble_rsp_wait();
			cnt_bytes += len;
			cnt_packets += 1;
		}
		ble_sleep(true);
		MAP_GPIO_setOutputLowOnPin(MSP_LED2R);
		do {
			read_message();
			ok = true;
			for (uint8_t i = NUM_CONN-NUM_LONG; i < NUM_CONN; i++) if (!recv_procedure_completed[i]) ok = false;
		} while (!ok); // wait for procedure completed from long payload acceptors
		offset += len;
	}
	MAP_GPIO_setOutputHighOnPin(MSP_LED2B);
	ble_sleep(false);
	for (uint8_t i = NUM_CONN-NUM_LONG; i < NUM_CONN; i++) {
		recv_procedure_completed[i] = false;
		ble_cmd_attclient_execute_write(i, 1);
		ble_rsp_wait();
	}
	ble_sleep(true);
	MAP_GPIO_setOutputLowOnPin(MSP_LED2B);
	do {
		read_message();
		ok = true;
		for (uint8_t i = 0; i < NUM_CONN; i++) if (!recv_procedure_completed[i]) ok = false;
	} while (!ok); // wait for procedure completed from all slaves including long payload acceptors
}


void connect_all(void)
{
	const uint8_t cmd_packet[2] = { 0x00, 0x00 };

	// connect to all slaves
	for (uint8_t i = 0; i < NUM_CONN; i++) {
reconnect:
		// connect direct
		// need to use slow connection interval, otherwise we would have
		// troubles with 7th or 8th slave - its broadcasting will not
		// fit into small free time slot
		ble_sleep(false);
		ble_cmd_gap_connect_direct(conn_addr[i], 0, 80, 80, 100, 0);
		ble_rsp_wait();
		ble_sleep(true);
		MAP_GPIO_setOutputHighOnPin(MSP_LED2B);
		do read_message(); while (!connected[i]); // wait for connection
		MAP_GPIO_setOutputLowOnPin(MSP_LED2B);

		// test connection using acknowledged command
		// to overcome the Connection Failed to be Established (0x023E) error
		// see BLUEGIGA BLUETOOTH SMART SOFTWARE V.1.4 API DOCUMENTATION page 223
		recv_procedure_completed[i] = false;
	    ble_sleep(false);
		ble_cmd_attclient_attribute_write(i, xgatt_command, 2, cmd_packet);
		ble_rsp_wait();
		ble_sleep(true);
		do {
			read_message();
			if (!connected[i]) goto reconnect;
		} while (!recv_procedure_completed[i]); // wait for procedure completed
	}

	// update connection interval
	// to allow maximum possible throughput for 8 slaves
    ble_sleep(false);
	for (uint8_t i = 0; i < NUM_CONN; i++) {
		ble_cmd_connection_update(i, 6, 16, 0, 100);
		ble_rsp_wait();
	}
    ble_sleep(true);

	// check again
    // to force the connection interval update, which is done after several slots
	for (uint8_t i = 0; i < NUM_CONN; i++) {
		// test connection using acknowledged command
		recv_procedure_completed[i] = false;
	    ble_sleep(false);
		ble_cmd_attclient_attribute_write(i, xgatt_command, 2, cmd_packet);
		ble_rsp_wait();
		ble_sleep(true);
		do {
			read_message();
		} while (!recv_procedure_completed[i]); // wait for procedure completed
	}

}

#else

void ble_evt_attributes_value(const struct ble_msg_attributes_value_evt_t *msg)
{
	if (msg->handle == xgatt_command) {
		MAP_GPIO_setOutputHighOnPin(MSP_LED2R);
	    tick_counter = 0; do {} while (tick_counter < 2); // wait >1ms
		MAP_GPIO_setOutputLowOnPin(MSP_LED2R);
	}
	else if (msg->handle == xgatt_benchmark) {
		MAP_GPIO_setOutputHighOnPin(MSP_LED2B);
	    tick_counter = 0; do {} while (tick_counter < 2); // wait >1ms
		MAP_GPIO_setOutputLowOnPin(MSP_LED2B);
	}
	else if (msg->handle == xgatt_data) {
		// always when msg->reason == attributes_attribute_change_reason_write_request_user
		MAP_GPIO_setOutputHighOnPin(MSP_LED2R);
	    ble_sleep(false);
		ble_cmd_attributes_user_write_response(0, 0);
		ble_rsp_wait();
	    ble_sleep(true);
		MAP_GPIO_setOutputLowOnPin(MSP_LED2R);
	}
}


void ble_evt_attributes_user_read_request(const struct ble_msg_attributes_user_read_request_evt_t *msg)
{
	const uint8_t dummy_data[] = "abcdefghijklmnopqrstuvwxyz";

	if (msg->handle == xgatt_data) {
		MAP_GPIO_setOutputHighOnPin(MSP_LED2G);

		uint8_t curr_len = response_len - msg->offset;
		if (curr_len > msg->maxsize) curr_len = msg->maxsize;

	    ble_sleep(false);
		ble_cmd_attributes_user_read_response(0, 0, curr_len, dummy_data);
		ble_rsp_wait();
	    ble_sleep(true);

		MAP_GPIO_setOutputLowOnPin(MSP_LED2G);
	}
}


void ble_evt_connection_status(const struct ble_msg_connection_status_evt_t *msg)
{
    if (msg->flags & connection_connected) MAP_GPIO_setOutputHighOnPin(MSP_LED1);
}


void ble_evt_connection_disconnected(const struct ble_msg_connection_disconnected_evt_t *msg)
{
	MAP_GPIO_setOutputLowOnPin(MSP_LED1);
    ble_sleep(false);
	ble_cmd_gap_set_mode(gap_general_discoverable, gap_undirected_connectable);
	ble_rsp_wait();
    ble_sleep(true);
}


void ble_rsp_system_address_get(const struct ble_msg_system_address_get_rsp_t *msg)
{
	switch (msg->address.addr[0]) {
		case 0xCE: response_len = 30;  break; // EPS
		case 0xC5: response_len = 120; break; // ADCS
		case 0xC6: response_len = 30;  break; // GPS
		case 0xC8: response_len = 10;  break; // Propulsion
		case 0xC9: response_len = 10;  break; // TC Radio
		case 0xCA: response_len = 10;  break; // Payload
		case 0xC7: response_len = 10;  break; // Data Storage
		case 0xCC: response_len = 10;  break; // PL Radio
	}
}

#endif


int main(void) 
{
	char s[128];

	WDT_A_holdTimer();

	/* preinit all pulldowns/pullups */
	P1REN = 0xFF;
	P2REN = 0xFF;
	P3REN = 0xFF;
	P4REN = 0xFF;
	P5REN = 0xFF;
	P6REN = 0xFF;
	P7REN = 0xFF;
	P8REN = 0xFF;
	P9REN = 0xFF;
	P10REN = 0xFF;

	/* Selecting P1.2 and P1.3 in UART mode */
    MAP_GPIO_setAsPeripheralModuleFunctionInputPin(GPIO_PORT_P1, GPIO_PIN2 | GPIO_PIN3, GPIO_PRIMARY_MODULE_FUNCTION);

    /* Configuring UART Module */
    MAP_UART_initModule(EUSCI_A0_BASE, &uartConfig_PC);

    /* Enable UART module */
    MAP_UART_enableModule(EUSCI_A0_BASE);

    /* Configuring SysTick  */
    MAP_SysTick_enableModule();
    MAP_SysTick_setPeriod(48000);
    MAP_SysTick_enableInterrupt();

    /* Enabling interrupts */
    MAP_Interrupt_enableMaster();

    /* board LEDs */
    MAP_GPIO_setAsInputPinWithPullUpResistor(MSP_S1); // S1
    MAP_GPIO_setAsInputPinWithPullUpResistor(MSP_S2); // S2
    MAP_GPIO_setAsOutputPin(MSP_LED1); // LED1
    MAP_GPIO_setAsOutputPin(MSP_LED2R); // LED2-R
    MAP_GPIO_setAsOutputPin(MSP_LED2G); // LED2-G
    MAP_GPIO_setAsOutputPin(MSP_LED2B); // LED2-B
    MAP_GPIO_setOutputLowOnPin(MSP_LED1);
    MAP_GPIO_setOutputLowOnPin(MSP_LED2R);
    MAP_GPIO_setOutputLowOnPin(MSP_LED2G);

    MAP_GPIO_setOutputHighOnPin(MSP_LED2B);

    // setup BLE module
    ble_init_hw();

    ble_cmd_system_address_get();
	ble_rsp_wait();

    ble_sleep(true);

	sprintf(s, "init ok, sleep for 10sec\n");
	for (uint8_t i = 0; i < strlen(s); i++) MAP_UART_transmitData(EUSCI_A0_BASE, s[i]);

    tick_counter = 0; do {} while (tick_counter < 10000); // wait 10sec

#ifdef OBC

    MAP_GPIO_setOutputLowOnPin(MSP_LED2B);

    // connect all slave BLE devices
    connect_all();

/*
	sprintf(s, "all boards connected, sleep for 10sec\n");
	for (uint8_t i = 0; i < strlen(s); i++) MAP_UART_transmitData(EUSCI_A0_BASE, s[i]);
    tick_counter = 0; do {} while (tick_counter < 10000); // wait 10sec
*/

    MAP_GPIO_setOutputHighOnPin(MSP_LED1);

    tick_counter = 0;
    bool update = true;

    while (1)
    {
	    do {} while (read_message()); // process buffered async responses
	    uint32_t time = tick_counter;

#if TEST_MODE == 1
	    main_benchmark_test();
	    if (tick_second) {
	    	update = true;
	    	tick_second = false;
	    }
#elif TEST_MODE == 2
	    main_scenario_test();
	    update = true;
#elif TEST_MODE == 3
		if (tick_second) {
			main_scenario_test();
			update = true;
			tick_second = false;
		}
#endif

		time -= tick_counter;

		if (update) {
			ble_sleep(false);
			ble_cmd_system_get_counters();
			ble_rsp_wait();
			ble_sleep(true);

			sprintf(s, "tick %u, time %4d, packet %u, %ubps, %.1fpps, txerror %.1f%%, rxerror %.1f%%\n",
				tick_counter, time, cnt_packets,
				(uint32_t)(cnt_bytes * 1000ULL * 8 / tick_counter), cnt_packets * 1000. / tick_counter,
				100. * txretry / (txok+txretry),
				100. * rxfail / (rxok+rxfail)
			);
			for (uint8_t i = 0; i < strlen(s); i++) MAP_UART_transmitData(EUSCI_A0_BASE, s[i]);

			txok = 0; txretry = 0; rxok = 0; rxfail = 0;
			update = false;
		}

		if (MAP_GPIO_getInputPinValue(MSP_S1) == 0) break;
    }

	// disconnect all slaves
	ble_sleep(false);
	for (uint8_t connection_handle = 0; connection_handle < NUM_CONN; connection_handle++) {
		ble_cmd_connection_disconnect(connection_handle);
		ble_rsp_wait();
	    do read_message(); while (connected[connection_handle]); // wait for disconnection
	}

	ble_sleep(true);
    while (1) {}

#else

    ble_sleep(false);
    ble_cmd_gap_set_mode(gap_general_discoverable, gap_undirected_connectable);
	ble_rsp_wait();
    ble_sleep(true);

	MAP_GPIO_setOutputLowOnPin(MSP_LED2B);

    while (1)
    {
        read_message(); // process async messages
    }

#endif
}
